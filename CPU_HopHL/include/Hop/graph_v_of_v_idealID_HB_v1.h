#pragma once
#include <boost/heap/fibonacci_heap.hpp>
#include <Hop/graph_v_of_v_idealID_HB_canonical_repair.h>

using namespace std;

struct HBPLL_v1_node {
public:
    int vertex, parent_vertex, hop;
    double priority_value;
};
bool operator<(HBPLL_v1_node const &x, HBPLL_v1_node const &y) {
    return x.priority_value > y.priority_value;
}

typedef typename boost::heap::fibonacci_heap<HBPLL_v1_node>::handle_type HBPLL_v1_node_handle;

void graph_v_of_v_idealID_HL_HB_v2_thread_function_HBDIJ(int v_k, int N, int upper_k, bool use_rank_pruning) {

    /* get unique thread id */
    mtx_599[max_N_ID_for_mtx_599 - 1].lock();
    int used_id = Qid_599.front();
    Qid_599.pop();
    mtx_599[max_N_ID_for_mtx_599 - 1].unlock();

    /* Temp_L_vk_599 stores the label (dist and hop) of vertex v_k */
    queue<int> Temp_L_vk_changes;
    mtx_599[v_k].lock();
    int L_vk_size = L_temp_599[v_k].size();
    for (int i = 0; i < L_vk_size; i++) {
        int L_vk_vertex = L_temp_599[v_k][i].vertex;
        Temp_L_vk_599[used_id][L_vk_vertex].push_back({L_temp_599[v_k][i].distance, L_temp_599[v_k][i].hop});
        Temp_L_vk_changes.push(L_vk_vertex);
    }
    mtx_599[v_k].unlock();

    /*
        dist_hop_599 stores the shortest distance from vk to any other vertices with its hop_cst,
        note that the hop_cst is determined by the shortest distance
    */
    queue<int> dist_hop_changes;
    dist_hop_599[used_id][v_k] = {0, 0};
    dist_hop_changes.push(v_k);

    boost::heap::fibonacci_heap<HBPLL_v1_node> Q;

    HBPLL_v1_node node;
    node.vertex = v_k;
    node.parent_vertex = v_k;
    node.hop = 0;
    node.priority_value = 0;
    Q.push(node);

    two_hop_label_v1 xx;
    long long int new_label_num = 0;

    while (Q.size() > 0) {
        node = Q.top();
        Q.pop();
        int u = node.vertex;

        if (v_k <= u || !use_rank_pruning) {  // rank pruning, r(v_k) > r(u)
            int u_parent = node.parent_vertex;
            int u_hop = node.hop;
            double P_u = node.priority_value;
            double P_u_with_error = P_u + 1e-5;
            double query_v_k_u = std::numeric_limits<double>::max();

            /* there are two upper_k judge in total */
            if (u_hop > upper_k)
                break;

            mtx_599[u].lock();
            auto size1 = L_temp_599[u].size();
            if (v_k != u) {
                for (int i = 0; i < size1; i++) {
                    int common_v = L_temp_599[u][i].vertex;
                    int size2 = Temp_L_vk_599[used_id][common_v].size();
                    for (int j = size2 - 1; j >= 0; j--) {
                        if (L_temp_599[u][i].hop + Temp_L_vk_599[used_id][common_v][j].second <= u_hop) {
                            double dis = L_temp_599[u][i].distance + Temp_L_vk_599[used_id][common_v][j].first;
                            if (query_v_k_u > dis) {
                                query_v_k_u = dis;
                            }
                            break;
                        }
                    }
                }
            }
            mtx_599[u].unlock();

            if (P_u_with_error < query_v_k_u) {  //pruning
                xx.vertex = v_k;
                xx.distance = P_u;
                xx.parent_vertex = u_parent;
                xx.hop = u_hop;

                mtx_599[u].lock();
                L_temp_599[u].push_back(xx);
                mtx_599[u].unlock();
                new_label_num++;

                /* update adj */
                int u_adj_size = ideal_graph_599[u].size();
                for (int i = 0; i < u_adj_size; i++) {
                    int adj_v = ideal_graph_599[u][i].first;
                    double ec = ideal_graph_599[u][i].second;

                    /* update node info */
                    node.vertex = adj_v;
                    node.parent_vertex = u;
                    node.priority_value = P_u + ec;
                    node.hop = u_hop + 1;

                    /* check if the edge is generated by R2: hop+1 */
                    double new_dist = node.priority_value;
                    if (new_edges_with_origin_ec_599.find({u, adj_v}) != new_edges_with_origin_ec_599.end() && adj_v != u_parent && adj_v != v_k) /* imp check to prevent infinite loop  */
                    {
                        if (new_edges_with_origin_ec_599[{u, adj_v}] != std::numeric_limits<double>::max()) {
                            if (ec < new_edges_with_origin_ec_599[{u, adj_v}]) {
                                /* add 1-edge (origin) info, here do not need to modify parent */
                                node.priority_value = new_edges_with_origin_ec_599[{u, adj_v}] + P_u;
                                node.parent_vertex = -u;
                                if (u == 0)
                                    node.parent_vertex = std::numeric_limits<int>::max();
                                // this node is surely the node with bigger dist but lower hop
                                Q.push(node);
                                node.parent_vertex = u;
                            }
                        }
                        /* update node info of 2-edge */
                        node.hop++;
                        node.priority_value = new_dist;
                    }
                    /* beyond upper_k, then stop expansion */
                    if (node.hop > upper_k) {
                        break;
                    }

                    /*
                        vertices not reached yet:
                        just add the distance and hop info
                    */
                    if (dist_hop_599[used_id][adj_v].first == std::numeric_limits<double>::max()) {
                        Q.push(node);
                        dist_hop_599[used_id][adj_v].first = node.priority_value;
                        dist_hop_599[used_id][adj_v].second = node.hop;
                        dist_hop_changes.push(adj_v);
                    }
                        /*
                            vertices already reached:
                            1. smaller distance, then update info
                            2. greater distance but smaller hop, add new info, do not update P_dij_599
                        */
                    else {
                        if (node.priority_value < dist_hop_599[used_id][adj_v].first) {
                            Q.push(node);
                            dist_hop_599[used_id][adj_v].first = node.priority_value;
                            dist_hop_599[used_id][adj_v].second = node.hop;
                            dist_hop_changes.push(adj_v);
                        } else if (node.hop < dist_hop_599[used_id][adj_v].second) {
                            Q.push(node);
                        }
                    }
                }
                /* stop update adj */
            }
        }
    }

    while (Temp_L_vk_changes.size() > 0) {
        vector<pair<double, int>>().swap( Temp_L_vk_599[used_id][Temp_L_vk_changes.front()] );
        Temp_L_vk_changes.pop();
    }

    while (dist_hop_changes.size() > 0) {
        dist_hop_599[used_id][dist_hop_changes.front()] = {std::numeric_limits<double>::max(), 0};
        dist_hop_changes.pop();
    }

    mtx_599[v_k].lock();
    vector<two_hop_label_v1>(L_temp_599[v_k]).swap(L_temp_599[v_k]);
    mtx_599[v_k].unlock();

    mtx_599[max_N_ID_for_mtx_599 - 1].lock();
    Qid_599.push(used_id);
    labal_size_599 = labal_size_599 + new_label_num;
    mtx_599[max_N_ID_for_mtx_599 - 1].unlock();

    if (labal_size_599 > max_labal_size_599) {
        throw reach_limit_error_string_MB;
    }

    if (std::chrono::duration_cast<std::chrono::nanoseconds>(std::chrono::high_resolution_clock::now() - begin_time_599).count() > max_run_time_nanoseconds_599) {
        throw reach_limit_error_string_time;
    }
}

void graph_v_of_v_idealID_HL_HB_v2_thread_function_HBDIJ_Qhandle(int v_k, int N, int upper_k, bool use_rank_pruning) {

    /* get unique thread id */
    mtx_599[max_N_ID_for_mtx_599 - 1].lock();
    int used_id = Qid_599.front();
    Qid_599.pop();
    mtx_599[max_N_ID_for_mtx_599 - 1].unlock();

    /* Temp_L_vk_599 stores the label (dist and hop) of vertex v_k */
    queue<int> Temp_L_vk_changes;
    mtx_599[v_k].lock();
    int L_vk_size = L_temp_599[v_k].size();
    for (int i = 0; i < L_vk_size; i++) {
        int L_vk_vertex = L_temp_599[v_k][i].vertex;
        Temp_L_vk_599[used_id][L_vk_vertex].push_back({L_temp_599[v_k][i].distance, L_temp_599[v_k][i].hop});
        Temp_L_vk_changes.push(L_vk_vertex);
    }
    mtx_599[v_k].unlock();

    /*
        dist_hop_599 stores the shortest distance from vk to any other vertices with its hop_cst,
        note that the hop_cst is determined by the shortest distance
    */
    queue<int> dist_hop_changes;
    dist_hop_599[used_id][v_k] = {0, 0};
    dist_hop_changes.push(v_k);
    /* {vertex, hop} -> ptr */
    map<pair<int,int>, pair<HBPLL_v1_node_handle, double>> Q_handle;
    boost::heap::fibonacci_heap<HBPLL_v1_node> Q;

    HBPLL_v1_node node;
    node.vertex = v_k;
    node.parent_vertex = v_k;
    node.hop = 0;
    node.priority_value = 0;
    Q_handle[{v_k, 0}] = {Q.push({node}), node.priority_value};

    two_hop_label_v1 xx;
    long long int new_label_num = 0;

    while (Q.size() > 0) {
        node = Q.top();
        Q.pop();
        int u = node.vertex;

        if (v_k <= u || !use_rank_pruning) {  // rank pruning, r(v_k) > r(u)
            int u_parent = node.parent_vertex;
            int u_hop = node.hop;
            double P_u = node.priority_value;
            double P_u_with_error = P_u + 1e-5;
            double query_v_k_u = std::numeric_limits<double>::max();

            /* there are two upper_k judge in total */
            if (u_hop > upper_k)
                break;

            mtx_599[u].lock();
            auto size1 = L_temp_599[u].size();
            if (v_k != u) {
                for (int i = 0; i < size1; i++) {
                    int common_v = L_temp_599[u][i].vertex;
                    int size2 = Temp_L_vk_599[used_id][common_v].size();
                    for (int j = size2 - 1; j >= 0; j--) {
                        if (L_temp_599[u][i].hop + Temp_L_vk_599[used_id][common_v][j].second <= u_hop) {
                            double dis = L_temp_599[u][i].distance + Temp_L_vk_599[used_id][common_v][j].first;
                            if (query_v_k_u > dis) {
                                query_v_k_u = dis;
                            }
                            break;
                        }
                    }
                }
            }
            mtx_599[u].unlock();

            if (P_u_with_error < query_v_k_u) {  //pruning
                xx.vertex = v_k;
                xx.distance = P_u;
                xx.parent_vertex = u_parent;
                xx.hop = u_hop;

                mtx_599[u].lock();
                L_temp_599[u].push_back(xx);
                mtx_599[u].unlock();
                new_label_num++;

                /* update adj */
                int u_adj_size = ideal_graph_599[u].size();
                for (int i = 0; i < u_adj_size; i++) {
                    int adj_v = ideal_graph_599[u][i].first;
                    double ec = ideal_graph_599[u][i].second;

                    /* update node info */
                    node.vertex = adj_v;
                    node.parent_vertex = u;
                    node.priority_value = P_u + ec;
                    node.hop = u_hop + 1;

                    /* check if the edge is generated by R2: hop+1 */
                    double new_dist = node.priority_value;
                    if (new_edges_with_origin_ec_599.find({u, adj_v}) != new_edges_with_origin_ec_599.end() && adj_v != u_parent && adj_v != v_k) /* imp check to prevent infinite loop  */
                    {
                        if (new_edges_with_origin_ec_599[{u, adj_v}] != std::numeric_limits<double>::max()) {
                            if (ec < new_edges_with_origin_ec_599[{u, adj_v}]) {
                                /* add 1-edge (origin) info, here do not need to modify parent */
                                node.priority_value = new_edges_with_origin_ec_599[{u, adj_v}] + P_u;
                                node.parent_vertex = -u;
                                if (u == 0)
                                    node.parent_vertex = std::numeric_limits<int>::max();
                                // this node is surely the node with bigger dist but lower hop
                                if ( Q_handle.find({adj_v, node.hop}) != Q_handle.end() ) {
                                    if ( Q_handle[{adj_v, node.hop}].second > node.priority_value ) {
                                        Q.update(Q_handle[{adj_v, node.hop}].first, node);
                                        Q_handle[{adj_v, node.hop}].second = node.priority_value;
                                    }
                                } else {
                                    Q_handle[{adj_v, node.hop}] = {Q.push(node), node.priority_value};
                                }
                                node.parent_vertex = u;
                            }
                        }
                        /* update node info of 2-edge */
                        node.hop++;
                        node.priority_value = new_dist;
                    }
                    /* beyond upper_k, then stop expansion */
                    if (node.hop > upper_k) {
                        break;
                    }

                    /*
                        vertices not reached yet:
                        just add the distance and hop info
                    */
                    if (dist_hop_599[used_id][adj_v].first == std::numeric_limits<double>::max()) {
                        Q_handle[{adj_v, node.hop}] = {Q.push(node), node.priority_value};
                        dist_hop_599[used_id][adj_v].first = node.priority_value;
                        dist_hop_599[used_id][adj_v].second = node.hop;
                        dist_hop_changes.push(adj_v);
                    }
                        /*
                            vertices already reached:
                            1. smaller distance, then update info
                            2. greater distance but smaller hop, add new info, do not update
                        */
                    else {
//                        if (v_k == 0 && adj_v == 5 && u == 14) {
//                            cout << node.priority_value << endl;
//                            cout << node.hop << endl;
//                            cout << dist_hop_599[used_id][adj_v].first << endl;
//                            cout << dist_hop_599[used_id][adj_v].second << endl;
//                        }
                        if (node.priority_value < dist_hop_599[used_id][adj_v].first) {
                            if ( Q_handle.find({adj_v, node.hop}) != Q_handle.end() ) {
                                if ( Q_handle[{adj_v, node.hop}].second > node.priority_value ) {
                                    Q.update(Q_handle[{adj_v, node.hop}].first, node);
                                    Q_handle[{adj_v, node.hop}].second = node.priority_value;
                                }
                            } else {
                                Q_handle[{adj_v, node.hop}] = {Q.push(node), node.priority_value};
                            }
                            dist_hop_599[used_id][adj_v].first = node.priority_value;
                            dist_hop_599[used_id][adj_v].second = node.hop;
                            dist_hop_changes.push(adj_v);
                        } else if (node.hop < dist_hop_599[used_id][adj_v].second) {
                            if ( Q_handle.find({adj_v, node.hop}) != Q_handle.end() ) {
                                if ( Q_handle[{adj_v, node.hop}].second > node.priority_value ) {
                                    Q.update(Q_handle[{adj_v, node.hop}].first, node);
                                    Q_handle[{adj_v, node.hop}].second = node.priority_value;
                                }
                            } else {
                                Q_handle[{adj_v, node.hop}] = {Q.push(node), node.priority_value};
                            }
                        }
                    }
                }
                /* stop update adj */
            }
        }
    }

    while (Temp_L_vk_changes.size() > 0) {
        vector<pair<double, int>>().swap( Temp_L_vk_599[used_id][Temp_L_vk_changes.front()] );
        Temp_L_vk_changes.pop();
    }

    while (dist_hop_changes.size() > 0) {
        dist_hop_599[used_id][dist_hop_changes.front()] = {std::numeric_limits<double>::max(), 0};
        dist_hop_changes.pop();
    }

    mtx_599[v_k].lock();
    vector<two_hop_label_v1>(L_temp_599[v_k]).swap(L_temp_599[v_k]);
    mtx_599[v_k].unlock();

    mtx_599[max_N_ID_for_mtx_599 - 1].lock();
    Qid_599.push(used_id);
    labal_size_599 = labal_size_599 + new_label_num;
    mtx_599[max_N_ID_for_mtx_599 - 1].unlock();

    if (labal_size_599 > max_labal_size_599) {
        throw reach_limit_error_string_MB;
    }

    if (std::chrono::duration_cast<std::chrono::nanoseconds>(std::chrono::high_resolution_clock::now() - begin_time_599).count() > max_run_time_nanoseconds_599) {
        throw reach_limit_error_string_time;
    }
}

void graph_v_of_v_idealID_HB_v2_transfer_thread(vector<vector<two_hop_label_v2>> *output_L, int v_k, int value_M) {
    sort(L_temp_599[v_k].begin(), L_temp_599[v_k].end(), compare_two_hop_label_small_to_large);

    int size_vk = L_temp_599[v_k].size();
    if (size_vk == 0)
        return;

    if (value_M != 0) {
        for (int i = 0; i < size_vk; i++) {
            L_temp_599[v_k][i].distance += L_temp_599[v_k][i].hop * value_M;
        }
    }

    vector<tuple<double, int, int>> dist_info;
    dist_info.push_back({L_temp_599[v_k][0].distance, L_temp_599[v_k][0].parent_vertex, L_temp_599[v_k][0].hop});

    vector<two_hop_label_v2> L2_vk;
    for (int i = 1; i < size_vk; i++) {
        if (L_temp_599[v_k][i].vertex == L_temp_599[v_k][i-1].vertex) {
            dist_info.push_back({L_temp_599[v_k][i].distance, L_temp_599[v_k][i].parent_vertex, L_temp_599[v_k][i].hop});
        } else {
            two_hop_label_v2 xx;
            xx.dist_info.swap(dist_info);
            xx.vertex = L_temp_599[v_k][i-1].vertex;
            L2_vk.push_back(xx);
            vector<tuple<double, int, int>>().swap(dist_info);
            dist_info.push_back({L_temp_599[v_k][i].distance, L_temp_599[v_k][i].parent_vertex, L_temp_599[v_k][i].hop});
        }
    }
    two_hop_label_v2 xx;
    xx.dist_info.swap(dist_info);
    xx.vertex = L_temp_599[v_k][size_vk-1].vertex;
    L2_vk.push_back(xx);

    (*output_L)[v_k] = L2_vk;
    vector<two_hop_label_v1>().swap(L_temp_599[v_k]);
}

vector<vector<two_hop_label_v2>> graph_v_of_v_idealID_HB_v2_transfer_labels(int N, int max_N_ID, int num_of_threads, int value_M = 0) {
    vector<vector<two_hop_label_v2>> output_L(max_N_ID);
    vector<vector<two_hop_label_v2>> *p = &output_L;

    ThreadPool pool(num_of_threads);
    std::vector<std::future<int>> results;
    for (int v_k = 0; v_k < N; v_k++) {
        results.emplace_back(pool.enqueue([p, v_k, value_M] {
            graph_v_of_v_idealID_HB_v2_transfer_thread(p, v_k, value_M);
            return 1;
        }));
    }
    for (auto &&result : results)
        result.get();

    return output_L;
}

void graph_v_of_v_idealID_HB_v2(graph_v_of_v_idealID &input_graph, int max_N_ID , int num_of_threads, graph_v_of_v_idealID_two_hop_case_info_v1 &case_info) {
    //----------------------------------- step 1: initialization -----------------------------------
    cout << "step 1: initialization" << endl;

    auto begin = std::chrono::high_resolution_clock::now();
    /*information prepare*/
    labal_size_599 = 0;
    begin_time_599 = std::chrono::high_resolution_clock::now();
    max_run_time_nanoseconds_599 = case_info.max_run_time_seconds * 1e9;
    max_labal_size_599 = case_info.max_labal_size;

    if (max_N_ID > max_N_ID_for_mtx_599) {
        cout << "max_N_ID > max_N_ID_for_mtx_599; max_N_ID_for_mtx_599 is too small!" << endl;
        exit(1);
    }

    L_temp_599.resize(max_N_ID);
    int N = input_graph.size();

    /* thread info */
    ThreadPool pool(num_of_threads);
    std::vector<std::future<int>> results;
    int num_of_threads_per_push = num_of_threads * 100;

    ideal_graph_599 = input_graph;

    auto end = std::chrono::high_resolution_clock::now();
    case_info.time_initialization = std::chrono::duration_cast<std::chrono::nanoseconds>(end - begin).count() / 1e9;

    //----------------------------------------------- step 2: reduction ---------------------------------------------------------------
    cout << "step 2: reduction" << endl;

    /*redcution: add and remove certain edges*/
    case_info.reduction_measures_2019R2.clear();  // for using this function multiple times
    case_info.reduction_measures_2019R2.resize(max_N_ID, 0);

    begin = std::chrono::high_resolution_clock::now();
    if (case_info.use_2019R2) {
        case_info.MG_num = 0;
        for (int x = 0; x < N; x++) {
            if (ideal_graph_599[x].size() > 0) {
                if (x > ideal_graph_599[x][ideal_graph_599[x].size() - 1].first) {
                    case_info.reduction_measures_2019R2[x] = 2;
                    R2_reduced_vertices[x] = *new vector<pair<int, double>>(ideal_graph_599[x]);
                }
            }
        }
    } else if (case_info.use_enhanced2019R2) {
        case_info.MG_num = 0;
        for (int x = 0; x < N; x++) {
            if (ideal_graph_599[x].size() > 0) {
                if (x > ideal_graph_599[x][ideal_graph_599[x].size() - 1].first) {
                    case_info.reduction_measures_2019R2[x] = 2;
                    R2_reduced_vertices[x] = *new vector<pair<int, double>>(ideal_graph_599[x]);
                }
            }
        }
        int bound = case_info.max_degree_MG_enhanced2019R2;
        for (int x = N - 1; x >= 0; x--) {
            if (case_info.reduction_measures_2019R2[x] == 0 && ideal_graph_599[x].size() <= bound) {
                bool no_adj_MG_vertices = true;
                for (auto it = ideal_graph_599[x].begin(); it != ideal_graph_599[x].end(); it++) {
                    if (case_info.reduction_measures_2019R2[it->first] == 2) {
                        no_adj_MG_vertices = false;
                        break;
                    }
                }
                if (no_adj_MG_vertices) {
                    case_info.reduction_measures_2019R2[x] = 2;
                    R2_reduced_vertices[x] = *new vector<pair<int, double>>(ideal_graph_599[x]);
                }
            }
        }
    } else if (case_info.use_non_adj_reduc_degree) {
        case_info.MG_num = 0;
        int bound = case_info.max_degree_MG_enhanced2019R2;
        for (int x = N - 1; x >= 0; x--) {
            if (case_info.reduction_measures_2019R2[x] == 0 && ideal_graph_599[x].size() <= bound) {
                bool no_adj_MG_vertices = true;
                for (auto it = ideal_graph_599[x].begin(); it != ideal_graph_599[x].end(); it++) {
                    if (case_info.reduction_measures_2019R2[it->first] == 2) {
                        no_adj_MG_vertices = false;
                        break;
                    }
                }
                if (no_adj_MG_vertices) {
                    case_info.reduction_measures_2019R2[x] = 2;
                    R2_reduced_vertices[x] = *new vector<pair<int, double>>(ideal_graph_599[x]);
                }
            }
        }
    }
    for (int x = N - 1; x >= 0; x--) {
        if (case_info.reduction_measures_2019R2[x] == 2) {
            /*add edge*/
            auto it1 = ideal_graph_599[x].begin();
            for (int m = ideal_graph_599[x].size() - 1; m > 0; m--) {
                for (int n = m - 1; n >= 0; n--) {
                    double s_vPLUSv_t = (it1 + m)->second + (it1 + n)->second;
                    int e1 = (it1 + m)->first;
                    int e2 = (it1 + n)->first;
                    double origin_ec = graph_v_of_v_idealID_edge_weight(ideal_graph_599, e1, e2);
                    if (s_vPLUSv_t < origin_ec) {
                        graph_v_of_v_idealID_add_edge(ideal_graph_599, e1, e2, s_vPLUSv_t);
                        new_edges_with_middle_v_599[{e1, e2}] = x;
                        new_edges_with_middle_v_599[{e2, e1}] = x;
                        /* only record the origin edge, in case of the edge is updated many times */
                        if (new_edges_with_origin_ec_599.find({e1, e2}) == new_edges_with_origin_ec_599.end()) {
                            new_edges_with_origin_ec_599[{e1, e2}] = origin_ec;
                            new_edges_with_origin_ec_599[{e2, e1}] = origin_ec;
                        }
                    }
                }
            }
            /*remove edge*/
            case_info.MG_num++;
            graph_v_of_v_idealID_remove_all_adjacent_edges(ideal_graph_599, x);
        }
    }
    end = std::chrono::high_resolution_clock::now();
    case_info.time_reduction = std::chrono::duration_cast<std::chrono::nanoseconds>(end - begin).count() / 1e9;  // s

    //----------------------------------------------- step 3: generate labels ---------------------------------------------------------------
    cout << "step 3: generate labels" << endl;
    begin = std::chrono::high_resolution_clock::now();

    /*searching shortest paths*/
    int upper_k = case_info.upper_k == 0 ? std::numeric_limits<int>::max() : case_info.upper_k;
    bool use_rank_pruning = case_info.use_rank_pruning;

    Temp_L_vk_599.resize(num_of_threads);
    dist_hop_599.resize(num_of_threads);
    for (int i = 0; i < num_of_threads; i++) {
        Temp_L_vk_599[i].resize(N);
        dist_hop_599[i].resize(N, {std::numeric_limits<double>::max(), 0});
        Qid_599.push(i);
    }

    int push_num = 0;
    for (int v_k = 0; v_k < N; v_k++) {
        if (ideal_graph_599[v_k].size() > 0) {
            results.emplace_back(
                    pool.enqueue([v_k, N, upper_k, use_rank_pruning] {
                        graph_v_of_v_idealID_HL_HB_v2_thread_function_HBDIJ_Qhandle(v_k, N, upper_k, use_rank_pruning);
                        return 1;
                    }));
            push_num++;
        }
        if (push_num % num_of_threads_per_push == 0) {
            for (auto &&result : results)
                result.get();
            results.clear();
        }
    }

    for (auto &&result : results)
        result.get();

    end = std::chrono::high_resolution_clock::now();
    case_info.time_generate_labels = std::chrono::duration_cast<std::chrono::nanoseconds>(end - begin).count() / 1e9;  // s

    /*
        update predecessors for this non_adj_reduction,
        this update is for correct recursive direction.
    */
    begin = std::chrono::high_resolution_clock::now();
    for (auto it = new_edges_with_middle_v_599.begin(); it != new_edges_with_middle_v_599.end(); it++) {
        int e1 = it->first.first;
        int e2 = it->first.second;
        int middle_k = it->second;
        for (int j = L_temp_599[e1].size() - 1; j >= 0; j--) {
            if (L_temp_599[e1][j].parent_vertex == e2) {
                L_temp_599[e1][j].parent_vertex = middle_k;
            }
        }
    }
    for (auto it = new_edges_with_middle_v_599.begin(); it != new_edges_with_middle_v_599.end(); it++) {
        int e1 = it->first.first;
        int e2 = it->first.second;
        int middle_k = it->second;
        for (int j = L_temp_599[e1].size() - 1; j >= 0; j--) {
            if (L_temp_599[e1][j].parent_vertex < 0) {
                L_temp_599[e1][j].parent_vertex *= (-1);
                continue;
            }
            if (L_temp_599[e1][j].parent_vertex == std::numeric_limits<int>::max()) {
                L_temp_599[e1][j].parent_vertex = 0;
                continue;
            }
        }
    }
    end = std::chrono::high_resolution_clock::now();
    case_info.time_update_predecessors = std::chrono::duration_cast<std::chrono::nanoseconds>(end - begin).count() / 1e9;

    //----------------------------------------------- step 4: canonical_repair---------------------------------------------------------------
    cout << "step 4: canonical_repair" << endl;

    L2_temp_599 = graph_v_of_v_idealID_HB_v2_transfer_labels(N, max_N_ID, num_of_threads, case_info.value_M);
    case_info.L2 = L2_temp_599;

    if (case_info.use_canonical_repair) {
        canonical_removed_labels = 0;
        begin = std::chrono::high_resolution_clock::now();
        /* print label before canonical repair if necessary */
        if (case_info.print_label_before_canonical_fix) {
            cout << "label_before_canonical_fix:" << endl;
            for (int i = 0; i < L_temp_599.size(); i++) {
                cout << "L[" << i << "]:\t";
                int ii = i;
                for (int j = 0; j < L_temp_599[ii].size(); j++) {
                    cout << "{" << L_temp_599[ii][j].vertex << "," << L_temp_599[ii][j].distance << "," << L_temp_599[ii][j].parent_vertex << "," << L_temp_599[ii][j].hop << "}";
                }
                cout << endl;
            }
        }

        canonical_repair_multi_threads_v3(case_info, num_of_threads);
        end = std::chrono::high_resolution_clock::now();
        case_info.time_canonical_repair = std::chrono::duration_cast<std::chrono::nanoseconds>(end - begin).count() / 1e9;
    }

    graph_v_of_v_idealID_two_hop_clear_global_values();
}